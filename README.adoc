
= Spring Boot Starter for Bucket4j

https://github.com/vladimir-bukhtoyarov/bucket4j

*Examples:*
https://github.com/MarcGiffing/bucket4j-spring-boot-starter-examples[bucket4j-spring-boot-starter-examples]

This project provides an integration of Bucket4j for limiting the rate of access to REST APIs.
To limit the access of requests this projects provides predefined filter types which can be reused for simple configurations options.

== Autoconfiguration:

* Detects the CachManger(JCache) and configures it for Bucket4j. You can configure the different CacheManager with https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html[spring-boot-starter-cache]
* *Servlet Filter* or *ZuulFilter* registration for limiting the rate
* Configuration via properties
** cache name
** url
** multiple bandwith (capacity, time unit)
** predefined filter types

== Bucket4j properties



[source, properties]
----

bucket4j.enabled=true # enable/disable bucket4j support
bucket4j.filters[0].cache-name=buckets # the name of the cache key
bucket4j.filters[0].filter-method=servlet # [servlet,zuul]
bucket4j.filters[0].filter-order=0 
bucket4j.filters[0].http-response-body={ "message": "Too many requests" } # the json response which should be added to the body
bucket4j.filters[0].url=/*
bucket4j.filters[0].strategy=first # [first, all] if multiple rate limits configured the 'first' strategy stops the processing after the first matching 
bucket4j.filters[0].rate-limits[0].filter-key-type=expression [default, ip, expression]
bucket4j.filters[0].rate-limits[0].expression=getRemoteAddress() # if filter-key-type is expression the key can be retrieved by an Spring Expression Language
bucket4j.filters[0].rate-limits[0].execute-condition=1==1 # an optional SpEl expression to decide to execute the rate limit or not
bucket4j.filters[0].rate-limits[0].skip-condition=1==1 # an optional SpEl expression to skip the rate limit
bucket4j.filters[0].rate-limits[0].bandwidths[0].capacity=10
bucket4j.filters[0].rate-limits[0].bandwidths[0].time=1
bucket4j.filters[0].rate-limits[0].bandwidths[0].unit=minutes
----

=== Filter types (bad name, should be renamed in the feature)

Filter types are predefined configuration option on how to define the key which should be used to limiting the requests.

==== Default

The default options doesn't differentiates between incoming requests (user, ip, etc). Its a general limiting.

==== IP

The IP filter type limits the access based on the IP address (httpServletRequest.getRemoteAddr()). So each IP address will independently throttled.

==== Expression

The expression based filter type provides the most flexible one but uses the Spring Expression Language (SpEL) which is maybe not the best choice for optimal performance.
But is provides an easy way to configure the limiting in different environments without writing one line of code.

*Limiting based on IP-Address*:
[source]
----
getRemoteAddress()
----


*Limiting based on Username - If not logged in use IP-Address*:
[source]
----
@securityService.username()?: getRemoteAddr()
----
[source,java]
----
@Service
public class SecurityService {

	public String username() {
		String name = SecurityContextHolder.getContext().getAuthentication().getName();
		if(name == "anonymousUser") {
			return null;
		}
		return name;
	}
	
}
----
 

== Configuration via properties

 Simple configuration

[source,yml]
----
bucket4j:
  enabled: true
  filters: 
  - cache-name: buckets 
    url: /*
    rate-limits:
    - filter-key-type: default 
      bandwidths: 
      - capacity: 5 
        time: 10
        unit: seconds
----

Multiple filters

[source,yml]
----
bucket4j:
  enabled: true
  configs: # each config entry creates one servlet filter or zuul filter
  - cache-name: buckets # create new servlet filter with bucket4j configuration
    url: /*
    rate-limits:
    - filter-key-type: default # filter all requests independently from the source
      bandwidths: # maximum of 5 requests within 10 seconds
      - capacity: 5 
        time: 10
        unit: seconds
  - cache-name: buckets 
    url: /abc*
    rate-limits:
    - filter-key-type: ip # IP based filter
      bandwidths: # maximum of 5 requests within 10 seconds
      - capacity: 5 
        time: 10
        unit: seconds
  - cache-name: buckets 
    url: /xyz*
    rate-limits:
    - filter-key-type: expression  # expression based filter key evaluation
    	  skip-condition: "@securityService.username() == 'admin'" # we don't check the rate limit if user is the admin user
    	  expression: "@securityService.username()?: getRemoteAddr()" # use the username as key. if authenticated use the ip address 
      bandwidths: 
    - capacity: 100
      time: 1
      unit: seconds
    - capacity: 10000
      time: 1
      unit: minutes    
----

One filter with different 

[source,yml]
----
bucket4j:
  enabled: true
  filters:
  - cache-name: buckets   
    filter-method: servlet 
    url: /*
    rate-limits:
    - filter-key-type: expression
      execute-condition:  @securityService.notSignedIn() # only for not logged in users
      expression: "getRemoteAddr()"
      bandwidths:
      - capacity: 10
        time: 1
        unit: minutes
    - filter-key-type: expression
      execute-condition: "@securityService.username() != 'admin'" # strategy is only evaluate first. so the user must be logged in and user is not admin 
      expression: @securityService.username()
      bandwidths:
      - capacity: 1000
        time: 1
        unit: minutes
    - filter-key-type: expression
      execute-condition:  "@securityService.username() == 'admin'"  # user is admin
      expression: @securityService.username()
      bandwidths:
      - capacity: 1000000000
        time: 1
        unit: minutes
    
----

== Configuration via @Bean

